<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <link rel="stylesheet" href="../css/blog.css" />

        <title>GSoC 2023 Week 5</title>
    </head>

    <body>
        <div class="container" id="container">
            <div class="header">
                <div class="title">GSoC 2023 Week 5 - <code>SetVector</code> Speedup</div>
                <div class="date">09 June 2023</div>
                <br />
                <hr class="separator" />
            </div>
            <div class="links">
                <a href="../index.html">home</a>
                <span class="list-separator">|</span>
                <a href="../blog/index.html">blogs</a>
            </div>
            <div class="scaler">
                <span id="scalercontent">
                    <span class="small-plus">A</span>
                    <input
                        type="range"
                        min="1"
                        max="100"
                        value="100"
                        class="slider"
                        id="thescaler"
                        title="Zoom slider" />
                    <span class="big-plus">A</span>
                    <input
                        id="slidervalue"
                        type="number"
                        min="0.5"
                        max="1.0"
                        step="0.01"
                        placeholder="1.00"
                        title="Zoom amount"
                /></span>
            </div>
            <div class="content">
                <p><p>
  This blog post is related to my
  <a href="https://summerofcode.withgoogle.com/programs/2023/projects/JdqGUwNq">GSoC
    2023 Project</a>.
</p>
<p>
  This week, I was able to get some pretty good results: 0.4% geomean, just by changing the type of
  <code>PruningList</code>. This also led to finding major performance improvements in <code>SetVector</code>.
</p>
<p>
  While looking through the <code>DAGCombiner</code> code, I noticed one thing: the pruning list stores pointers, but it
  doesn't use the standard pointer container: <code>SmallPtrSet</code>. At the time, I didn't know that
  the insertion order into pruning list matters as much as the worklist, this is because operands that do have uses of
  nodes which get pruned get put into the worklist to be processed.
</p>
<p>
  Thus, if the iteration order over the pruning list is not well-defined, the order of combinations done by the
  <code>DAGCombiner</code> also become undefined, which is obviously not good. This is the issue that is caused by
  using <code>SmallPtrSet</code>. I still think the solution I came up with is quite interesting, so I'll explain it a
  little.
</p>
<p>
  When I switched to using only one <code>SmallPtrSet</code>, the problem arose that entries may be added to the pruning
  list while pruning is being done. The solution that I had come up with involved going over the whole pruning list
  without deleting anything, then clearing it at the end. However, as nodes could be added to it while iterating, this 
  would invalidate the iterators and cause a crash when iterating. So, I had to somehow prevent the iterators from being
  invalidated while I iterated over them.
</p>
<p>
  The solution that I came up with for this was: create two pruning lists, one which stores the nodes which are 
  currently being pruned, and one which stores the nodes which get added by calls to
  <code>recursivelyDeleteUnusedNodes</code>. Then, a pointer is used to decided which list is being modified currently
  by calls to <code>RemoveFromWorklist</code>. I like to compare this system to a double buffer on a GPU, where one
  buffer stores the frame currently being shown (front buffer, i.e. the pruning list which is currently being cleared),
  and one buffer where the actual rendering work is done (back buffer, i.e. the pruning list where nodes are being
  added). 
</p>
<p>
  Then, once the back buffer is ready to be shown, the pointers are flipped and the back buffer becomes the front
  buffer and vice versa. I did the same thing with the pointer, once one list was empty the other was set to be the
  one which was to be emptied, and it kept flip-flopping this way until both lists were empty. This gave a pretty damn
  good result:
  <a href="https://llvm-compile-time-tracker.com/compare.php?from=94cefe41e6f20e9e2c823830dfd9ada22d898e2a&to=f614cddd962bfa759c3ac51454580145507fe105&stat=instructions%3Au">
    0.21% geomean.
  </a>
</p>
<p>
  Of course, my mentor came up with a much better solution: why not just not modify the pruning list while it is being
  cleared? This made a lot of sense, the only nodes which get added to the pruning list while it is being cleared are
  those which have uses, so they won't be pruned anyways. So, by stopping that from happening, the iterators are not
  invalidated and the whole flip flopping system isn't even needed at all. This gave a further performance boost:
  <a href="https://llvm-compile-time-tracker.com/compare.php?from=f614cddd962bfa759c3ac51454580145507fe105&to=3e91b011bed5b9cfa17f95782c75edf722e9cfab&stat=instructions%3Au">
    0.08% geomean.
  </a>
</p>
<p>
  However, there was still the problem with using <code>SmallPtrSet</code>: it has an undefined iteration order. This
  means that if issues occur in some build where combines are not done in the right order, there may be a chance that it
  is non-reproducible, which is really not fun. So, my mentor suggested changing the type of the pruning list to 
  <code>SmallVector</code>, which would have a defined iteration order. To stop the iterators from getting invalidated,
  my mentor advised me to just get rid of the code which deleted from the pruning list: this did work pretty well,
  and also gave a really good speed boost: 
  <a href="https://llvm-compile-time-tracker.com/compare.php?from=94cefe41e6f20e9e2c823830dfd9ada22d898e2a&to=cbaafef5aa502e8a6db6ba72adbe484649c65b3c&stat=instructions%3Au">
    0.42% geomean.
  </a>
</p>
<p>
  This was a great result, but it came with one problem: because deleted nodes (which could be caused by other combines
  deleting unneeded/temporary nodes) could be reused by <code>SelectionDAG::getNode</code>, what could happen is that
  while iterating over the vector, a <code>DELETED_NODE</code> added to the pruning list but not deleted could be reused
  to create a new node, and if this new node had no uses, it would be automatically deleted.
</p>
<p>
  The fix for this is simple: just do a linear scan over the vector to remove deleted nodes from it when it is not 
  being cleared. This involves adding one boolean to the <code>DAGCombiner</code> class to track when the pruning list
  is being cleared. This gives a very slight performance regression:
  <a href="https://llvm-compile-time-tracker.com/compare.php?from=cbaafef5aa502e8a6db6ba72adbe484649c65b3c&to=a08e149543c7a486f2e227480ebdbeceb882f1d8&stat=instructions%3Au">
    0.02% geomean.
  </a>
</p>
<p>
  However, this solution requires doing a linear scan over the vector, which may lead to an issue with compile time
  explosion when the vector gets unexpectedly large. While this didn't happen for us, like with issue #33910 it is
  possible that a minor edge case can blow everything up. So, my mentor had an even better idea: just make
  <code>SmallSetVector</code> faster, as it does a set lookup instead of a linear scan.
</p>
<p>
  My mentor suggested that <code>SmallSetVector</code> can be made much better if it actually worked like the other
  <code>Small-</code> containers, where they do a linear scan for small sizes and a set lookup for bigger sizes.
  Implementing this was not that hard to be honest, the problem came from the compile times: because this header is
  included pretty much everywhere, every little change required recompiling EVERYTHING. This was slightly irritating,
  to say the least. Another major hurdle (the only one to be honest) was that there were some types which did not
  implement <code>operator==</code> for their types, only <code>getHashValue</code> for the <code>DenseSet</code>, so
  they could not be used in the small representation as this made the linear scan break.
</p>
<p>
  So, to fix this, I wrote a TMP monstrosity to detect if a type had <code>operator==</code> implemented for it, and
  used it to detect if a type could be used for the small representation. This change gave a really really good
  performance boost:
  <a href="https://llvm-compile-time-tracker.com/compare.php?from=94cefe41e6f20e9e2c823830dfd9ada22d898e2a&to=7e48d75e0a8a23a189399629dddf7678c11e0e1a&stat=instructions%3Au">
    0.36% geomean.
  </a>
</p>
<p>
  However, it involved a lot of code reimplementation between <code>SmallSetVector</code> and <code>SetVector</code>.
  To clean this up, my mentor suggested sending the parameter <code>N</code> to <code>SetVector</code> itself, which 
  would then allow reusing all the code in the base class. This gave a really clean diff: its just a few
  <code>if constexpr</code> blocks on top of the already existing code. This also gave a much better solution to
  deciding if a type could be used in the small representation or not: just check if the small size <code>N</code> is
  not equal to 0, where 0 is the default small size which means the small representation is not used at all.
</p>
<p>
  This gave an even greater performance boost:
  <a href="https://llvm-compile-time-tracker.com/compare.php?from=086601eac266ec253bf313c746390ff3e5656132&to=9ffdabecabcddde298ff313f5353f9e06590af62&stat=instructions%3Au">
    0.42% geomean.
  </a>
</p>
<p>
  I still feel that it is better to decide the value for <code>N</code> ourselves if it is not used, however this works
  as well. Next, my mentor found uses of <code>SetVector</code> where <code>SmallSetVector</code> would be better now 
  that the small representation of the set type isn't used, so I went and updated some places that used
  <code>SetVector</code> to use <code>SmallSetVector</code>. This gave a good performance boost on
  <code>-O0</code>:
  <a href="https://llvm-compile-time-tracker.com/compare.php?from=9ffdabecabcddde298ff313f5353f9e06590af62&to=97f1c0cde42ba85eaa67cbe89bec8fe45b801f21&stat=instructions%3Au">
    0.18% geomean.
  </a>
</p>
<p>
  This was much more fruitful than I could've asked for, and I'm really happy I was able to find this issue with the
  help of my mentor because it was getting pretty demoralizing not getting improvements for a week straight haha.
</p>
</p>
            </div>

            <div class="goto-top links">
                <a href="#container">go to top</a>
            </div>
            <br />
            <div class="embed">
                <span>GSoC 2023 Week 5 - <code>SetVector</code> Speedup</span>
                <span>Dhruv Chawla</span>
                <span>09 June 2023</span>
                <span class="links"><a href="https://dc03.github.io/blog/GSoC_2023_Week_5_2023_06_09.html">https://dc03.github.io/blog/GSoC_2023_Week_5_2023_06_09.html</a></span>
            </div>
            <br />
            <hr class="finish-line" />
        </div>
        <script src="../js/scaler.js"></script>
    </body>
</html>
